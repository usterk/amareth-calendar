<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amaréth Calendar — Solar</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #06060f;
            --surface: #0e0e1e;
            --surface-alt: #141428;
            --border: #252545;
            --border-glow: #3a3a6a;
            --text: #ddd6f0;
            --text-muted: #7a7498;
            --accent: #c8a84e;
            --accent-dim: #c8a84e22;
            --accent-glow: #c8a84e55;
            --glow: #6a4fd4;
            --glow-light: #9b7aff;
            --warning: #f85149;
            --warning-bg: #f8514922;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Raleway', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 1.5rem;
            position: relative;
            overflow-x: hidden;
        }

        /* ===== STARFIELD ===== */
        .starfield {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; pointer-events: none;
            background: radial-gradient(ellipse at 50% 40%, #0d0d28 0%, #060614 60%, #020208 100%);
        }
        .starfield::before, .starfield::after, .stars-3 {
            content: ''; position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; pointer-events: none;
        }
        .starfield::before {
            background-image:
                radial-gradient(1px 1px at 3% 28%, #fff8 0%, transparent 100%),
                radial-gradient(1px 1px at 8% 52%, #fff6 0%, transparent 100%),
                radial-gradient(1px 1px at 10% 20%, #fff9 0%, transparent 100%),
                radial-gradient(1px 1px at 13% 44%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 15% 70%, #fff6 0%, transparent 100%),
                radial-gradient(1px 1px at 18% 12%, #fff5 0%, transparent 100%),
                radial-gradient(1px 1px at 20% 90%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 23% 6%, #fff8 0%, transparent 100%),
                radial-gradient(1px 1px at 25% 35%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 30% 80%, #fff8 0%, transparent 100%),
                radial-gradient(1px 1px at 38% 48%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 43% 72%, #fff8 0%, transparent 100%),
                radial-gradient(1px 1px at 50% 65%, #fff5 0%, transparent 100%),
                radial-gradient(1px 1px at 55% 45%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 62% 22%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 68% 38%, #fff8 0%, transparent 100%),
                radial-gradient(1px 1px at 75% 58%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 80% 40%, #fff6 0%, transparent 100%),
                radial-gradient(1px 1px at 85% 82%, #fff6 0%, transparent 100%),
                radial-gradient(1px 1px at 90% 70%, #fff7 0%, transparent 100%),
                radial-gradient(1px 1px at 95% 10%, #fff8 0%, transparent 100%),
                radial-gradient(1.5px 1.5px at 7% 96%, #fffa 0%, transparent 100%),
                radial-gradient(1.5px 1.5px at 35% 50%, #ffda 0%, transparent 100%),
                radial-gradient(2px 2px at 51% 82%, #fffb 0%, transparent 100%),
                radial-gradient(2px 2px at 77% 60%, #fffb 0%, transparent 100%);
            animation: twinkle1 4s ease-in-out infinite alternate;
        }
        .starfield::after {
            background-image:
                radial-gradient(1px 1px at 2% 15%, #ccf5 0%, transparent 100%),
                radial-gradient(1px 1px at 12% 55%, #ccf4 0%, transparent 100%),
                radial-gradient(1px 1px at 22% 28%, #ccf5 0%, transparent 100%),
                radial-gradient(1px 1px at 32% 92%, #ccf4 0%, transparent 100%),
                radial-gradient(1px 1px at 41% 58%, #ccf4 0%, transparent 100%),
                radial-gradient(1px 1px at 52% 95%, #ccf6 0%, transparent 100%),
                radial-gradient(1px 1px at 62% 68%, #ccf4 0%, transparent 100%),
                radial-gradient(1px 1px at 72% 46%, #ccf5 0%, transparent 100%),
                radial-gradient(1px 1px at 82% 62%, #ccf4 0%, transparent 100%),
                radial-gradient(1px 1px at 91% 42%, #ccf6 0%, transparent 100%),
                radial-gradient(1.5px 1.5px at 47% 19%, #c8f5 0%, transparent 100%),
                radial-gradient(2px 2px at 33% 33%, #c8a84e55 0%, transparent 100%),
                radial-gradient(2px 2px at 73% 78%, #ff880033 0%, transparent 100%);
            animation: twinkle2 5s ease-in-out infinite alternate;
        }
        .stars-3 {
            background-image:
                radial-gradient(1px 1px at 4% 45%, #e8d0ff55 0%, transparent 100%),
                radial-gradient(1px 1px at 17% 30%, #ffe8d044 0%, transparent 100%),
                radial-gradient(1px 1px at 31% 15%, #e8d0ff44 0%, transparent 100%),
                radial-gradient(1px 1px at 46% 40%, #d0e8ff44 0%, transparent 100%),
                radial-gradient(1px 1px at 61% 85%, #d0e8ff44 0%, transparent 100%),
                radial-gradient(1px 1px at 76% 10%, #e8d0ff44 0%, transparent 100%),
                radial-gradient(1px 1px at 92% 65%, #ffe8d044 0%, transparent 100%),
                radial-gradient(160px 100px at 20% 35%, rgba(80,50,160,0.07) 0%, transparent 70%),
                radial-gradient(200px 120px at 65% 55%, rgba(40,60,140,0.06) 0%, transparent 70%),
                radial-gradient(120px 80px at 45% 15%, rgba(160,80,40,0.05) 0%, transparent 70%);
            animation: twinkle3 7s ease-in-out infinite alternate;
        }
        @keyframes twinkle1 { 0% { opacity: 0.65; } 100% { opacity: 1; } }
        @keyframes twinkle2 { 0% { opacity: 1; } 100% { opacity: 0.55; } }
        @keyframes twinkle3 { 0% { opacity: 0.7; } 100% { opacity: 0.95; } }

        /* ===== HEADER ===== */
        .header { text-align: center; margin-bottom: 1.5rem; }
        .header h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem; font-weight: 700;
            letter-spacing: 0.15em;
            background: linear-gradient(135deg, #c8a84e, #e8d88e, #c8a84e);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.2rem;
        }
        .header .subtitle {
            font-family: 'Cinzel', serif;
            color: var(--text-muted); font-size: 0.8rem;
            letter-spacing: 0.3em; text-transform: uppercase;
            margin-bottom: 0.6rem;
        }
        .theme-nav { display: flex; justify-content: center; gap: 0.25rem; flex-wrap: wrap; }
        .theme-nav .theme-active, .theme-nav .theme-link {
            padding: 0.3rem 0.75rem; border-radius: 20px; font-size: 0.8rem; text-decoration: none;
            font-family: 'Raleway', sans-serif;
        }
        .theme-nav .theme-active {
            background: linear-gradient(135deg, #d48020, #f0a830);
            color: #fff; font-weight: 600;
        }
        .theme-nav .theme-link {
            border: 1px solid var(--border); color: var(--text-muted);
        }
        .theme-nav .theme-link:hover { border-color: var(--accent); color: var(--text); }

        /* ===== CONFIG TOGGLE ===== */
        .config-toggle {
            background: none; border: 1px solid var(--border);
            color: var(--text-muted); padding: 0.25rem 0.6rem;
            border-radius: 20px; font-size: 0.78rem; cursor: pointer;
            transition: border-color 0.2s, color 0.2s;
        }
        .config-toggle:hover { border-color: var(--accent); color: var(--text); }

        /* ===== LOCATION BAR ===== */
        .location-bar {
            max-width: 600px;
            margin: 0 auto 1.5rem;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
        }
        .location-bar .loc-row {
            display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;
        }
        .location-bar button {
            background: linear-gradient(135deg, var(--glow), var(--glow-light));
            border: none; color: #fff;
            padding: 0.45rem 0.8rem; border-radius: 6px;
            cursor: pointer; font-size: 0.85rem; font-weight: 600; white-space: nowrap;
        }
        .location-bar button:hover { opacity: 0.9; }
        .location-bar button.secondary {
            background: var(--surface-alt);
            border: 1px solid var(--border); color: var(--text);
        }
        .location-bar input {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text); padding: 0.45rem 0.6rem;
            border-radius: 6px; font-size: 0.85rem; width: 90px;
        }
        .location-bar select {
            background: var(--bg); border: 1px solid var(--border);
            color: var(--text); padding: 0.45rem 0.6rem;
            border-radius: 6px; font-size: 0.85rem; flex: 1; min-width: 160px;
        }
        .location-bar select optgroup { color: var(--accent); }
        .location-bar select option { color: var(--text); background: var(--bg); }
        .location-bar .loc-label { color: var(--text-muted); font-size: 0.8rem; }
        .location-bar .loc-status { color: var(--text-muted); font-size: 0.8rem; margin-top: 0.5rem; }

        /* ===== POLAR WARNING ===== */
        .polar-warning {
            max-width: 600px; margin: 0 auto 1.5rem;
            background: var(--warning-bg); border: 1px solid var(--warning);
            border-radius: 10px; padding: 1.2rem; text-align: center;
        }
        .polar-warning .pw-icon { font-size: 2rem; margin-bottom: 0.5rem; }
        .polar-warning .pw-title { font-weight: 600; margin-bottom: 0.25rem; }
        .polar-warning .pw-detail { color: var(--text-muted); font-size: 0.85rem; }

        /* ===== SOLAR CLOCK ===== */
        .solar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 160px);
            padding: 1rem;
        }
        .solar-container svg {
            width: 100%;
            max-width: 520px;
            height: auto;
            display: block;
        }
        .solar-info {
            margin-top: 1.2rem;
            display: flex;
            gap: 2rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        .solar-info-item {
            text-align: center;
        }
        .solar-info-label {
            font-size: 0.6rem; letter-spacing: 0.2em; text-transform: uppercase;
            color: var(--text-muted); font-family: 'Raleway', sans-serif;
            margin-bottom: 0.15rem;
        }
        .solar-info-val {
            font-family: 'Cinzel', serif; font-size: 0.9rem; color: var(--text);
        }
    </style>
</head>
<body>
    <div class="starfield"></div>
    <div class="stars-3"></div>

    <div class="header">
        <h1>Amaréth Calendar</h1>
        <div class="subtitle">Tarcza Solarna</div>
        <nav class="theme-nav">
            <a href="index.html" class="theme-link" id="classic-link">Klasyczny</a>
            <a href="astro.html" class="theme-link" id="astro-link">✦ Astro</a>
            <span class="theme-active">☀ Solar</span>
            <button class="config-toggle" onclick="toggleConfig()">⚙ Lokalizacja</button>
        </nav>
    </div>

    <div class="location-bar" id="location-bar" style="display:none">
        <div class="loc-row">
            <button onclick="requestGeolocation()">Moja lokalizacja</button>
            <span class="loc-label">lub:</span>
            <select id="city-select" onchange="selectCity(this.value)">
                <option value="">-- Wybierz miasto --</option>
                <optgroup label="Polska">
                    <option value="52.23,21.01">Warszawa</option>
                    <option value="50.06,19.94">Krakow</option>
                    <option value="51.11,17.04">Wroclaw</option>
                    <option value="54.35,18.65">Gdansk</option>
                    <option value="53.01,18.60">Torun</option>
                </optgroup>
                <optgroup label="Europa">
                    <option value="51.51,-0.13">Londyn</option>
                    <option value="48.86,2.35">Paryz</option>
                    <option value="52.52,13.41">Berlin</option>
                    <option value="41.90,12.50">Rzym</option>
                    <option value="40.42,-3.70">Madryt</option>
                    <option value="59.33,18.07">Sztokholm</option>
                    <option value="55.68,12.57">Kopenhaga</option>
                    <option value="60.17,24.94">Helsinki</option>
                    <option value="38.72,-9.14">Lizbona</option>
                    <option value="37.98,23.73">Ateny</option>
                    <option value="50.45,30.52">Kijow</option>
                    <option value="55.76,37.62">Moskwa</option>
                    <option value="41.01,28.98">Stambu&#322;</option>
                </optgroup>
                <optgroup label="Ameryka Pn.">
                    <option value="40.71,-74.01">Nowy Jork</option>
                    <option value="34.05,-118.24">Los Angeles</option>
                    <option value="41.88,-87.63">Chicago</option>
                    <option value="43.65,-79.38">Toronto</option>
                    <option value="19.43,-99.13">Meksyk</option>
                </optgroup>
                <optgroup label="Ameryka Pd.">
                    <option value="-23.55,-46.63">Sao Paulo</option>
                    <option value="-34.60,-58.38">Buenos Aires</option>
                    <option value="-12.05,-77.04">Lima</option>
                    <option value="4.71,-74.07">Bogota</option>
                </optgroup>
                <optgroup label="Azja">
                    <option value="35.68,139.69">Tokio</option>
                    <option value="37.57,126.98">Seul</option>
                    <option value="39.90,116.40">Pekin</option>
                    <option value="31.23,121.47">Szanghaj</option>
                    <option value="22.32,114.17">Hongkong</option>
                    <option value="1.35,103.82">Singapur</option>
                    <option value="13.76,100.50">Bangkok</option>
                    <option value="28.61,77.21">Delhi</option>
                    <option value="19.08,72.88">Mumbaj</option>
                    <option value="25.20,55.27">Dubaj</option>
                    <option value="31.77,35.23">Jerozolima</option>
                </optgroup>
                <optgroup label="Afryka">
                    <option value="30.04,31.24">Kair</option>
                    <option value="-33.93,18.42">Kapsztad</option>
                    <option value="-1.29,36.82">Nairobi</option>
                    <option value="6.52,3.38">Lagos</option>
                </optgroup>
                <optgroup label="Oceania">
                    <option value="-33.87,151.21">Sydney</option>
                    <option value="-36.85,174.76">Auckland</option>
                </optgroup>
                <optgroup label="Arktyka/Antarktyka">
                    <option value="78.22,15.64">Longyearbyen (Svalbard)</option>
                    <option value="64.14,-21.90">Reykjavik</option>
                    <option value="69.65,18.96">Tromso</option>
                </optgroup>
            </select>
        </div>
        <div class="loc-row" style="margin-top:0.4rem">
            <input type="number" id="lat-input" placeholder="szer. geog." step="0.01" min="-90" max="90">
            <input type="number" id="lng-input" placeholder="dl. geog." step="0.01" min="-180" max="180">
            <button class="secondary" onclick="setManualLocation()">Ustaw</button>
        </div>
        <div class="loc-status" id="loc-status">Podaj lokalizacje aby obliczyc godziny planetarne i wschody/zachody Slonca</div>
    </div>

    <div id="polar-warning" style="display:none"></div>

    <div class="solar-container" id="solar-container">
        <div style="color: var(--text-muted)">Obliczam...</div>
    </div>

    <script>
        if (window.location.protocol === 'file:') {
            document.getElementById('solar-container').innerHTML =
                '<div style="color:#f85149;text-align:center;padding:2rem">ES modules wymagaja serwera HTTP.<br>Uruchom: <code>cd frontend && python3 -m http.server 8001</code><br>i otworz <code>http://localhost:8001/solar.html</code></div>';
        }
    </script>
    <script type="module">
        import {
            RAD, DAY_MS, ZODIAC, CHALDEAN, DAY_RULER_IDX, AMARETH_EPOCH,
            ELEMENT_LABELS, MODALITY_LABELS,
            getSunTimes, julianDay, sunLongitude,
            gregorianToZodiac, getPlanetaryHours, getMoonPhase,
            toAmareth, fmtAmarethYear, fmtTime,
        } from './engine.js';

        // ===== STATE =====
        let userLat = 53.01, userLng = 18.60;
        let polarState = null;

        const todayUTC = new Date(Date.UTC(new Date().getUTCFullYear(), new Date().getUTCMonth(), new Date().getUTCDate()));

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('lat') && urlParams.has('lng')) {
            const pLat = parseFloat(urlParams.get('lat'));
            const pLng = parseFloat(urlParams.get('lng'));
            if (!isNaN(pLat) && !isNaN(pLng)) { userLat = pLat; userLng = pLng; }
        }

        // ===== TIME <-> ANGLE MAPPING =====
        // Noon (12:00) = top (0 deg), clockwise. Midnight (0:00) = bottom (180 deg).
        function timeToAngle(decimalHours) {
            return ((decimalHours - 12 + 24) % 24) / 24 * 360;
        }
        function toDecimalHours(date) {
            return date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
        }

        // ===== SKY GRADIENT =====
        function lerpColor(a, b, t) {
            t = Math.max(0, Math.min(1, t));
            return {
                r: Math.round(a.r + (b.r - a.r) * t),
                g: Math.round(a.g + (b.g - a.g) * t),
                b: Math.round(a.b + (b.b - a.b) * t),
            };
        }

        // Hours since sunrise, handling midnight wrap. Result in [0, 24).
        function hoursSince(ref, h) {
            return ((h - ref) % 24 + 24) % 24;
        }

        function skyColor(angleDeg, sunriseH, sunsetH) {
            const hour = ((angleDeg / 360) * 24 + 12) % 24;

            // Day length (handles midnight wrap, e.g. sunrise=14 sunset=1 → dayLen=11)
            let dayLen = ((sunsetH - sunriseH) % 24 + 24) % 24;
            const nightLen = 24 - dayLen;

            // Hours since sunrise [0, 24)
            const t = hoursSince(sunriseH, hour);

            // Transition durations (clamped for very short days/nights)
            const DAWN_POST = Math.min(0.5, dayLen * 0.1);
            const DUSK_PRE  = Math.min(0.5, dayLen * 0.1);
            const DUSK_POST = Math.min(1.0, nightLen * 0.15);
            const DAWN_PRE  = Math.min(1.0, nightLen * 0.15);

            const NIGHT     = { r: 8,   g: 10,  b: 30  };
            const TWILIGHT  = { r: 20,  g: 18,  b: 55  };
            const DAWN_WARM = { r: 190, g: 105, b: 45  };
            const GOLDEN    = { r: 225, g: 165, b: 60  };
            const DAY_HOR   = { r: 90,  g: 150, b: 210 };
            const DAY_ZEN   = { r: 45,  g: 110, b: 190 };

            // DAWN: just after sunrise [0, DAWN_POST)
            if (t < DAWN_POST) {
                const p = DAWN_POST > 0 ? t / DAWN_POST : 1;
                return lerpColor(DAWN_WARM, DAY_HOR, p);
            }

            // FULL DAY: [DAWN_POST, dayLen - DUSK_PRE)
            if (t >= DAWN_POST && t < dayLen - DUSK_PRE) {
                const dayCore = dayLen - DAWN_POST - DUSK_PRE;
                const mid = dayLen / 2;
                const halfSpan = dayCore / 2;
                const dist = halfSpan > 0 ? Math.abs(t - mid) / halfSpan : 0;
                return lerpColor(DAY_ZEN, DAY_HOR, Math.min(1, dist * dist));
            }

            // PRE-DUSK: [dayLen - DUSK_PRE, dayLen)
            if (t >= dayLen - DUSK_PRE && t < dayLen) {
                const p = DUSK_PRE > 0 ? (t - (dayLen - DUSK_PRE)) / DUSK_PRE : 1;
                return lerpColor(DAY_HOR, GOLDEN, p);
            }

            // DUSK: [dayLen, dayLen + DUSK_POST)
            if (t >= dayLen && t < dayLen + DUSK_POST) {
                const p = DUSK_POST > 0 ? (t - dayLen) / DUSK_POST : 1;
                if (p < 0.5) return lerpColor(GOLDEN, DAWN_WARM, p * 2);
                return lerpColor(DAWN_WARM, TWILIGHT, (p - 0.5) * 2);
            }

            // PRE-DAWN: [24 - DAWN_PRE, 24)
            if (t >= 24 - DAWN_PRE) {
                const p = DAWN_PRE > 0 ? (t - (24 - DAWN_PRE)) / DAWN_PRE : 1;
                if (p < 0.5) return lerpColor(NIGHT, TWILIGHT, p * 2);
                return lerpColor(TWILIGHT, DAWN_WARM, (p - 0.5) * 2);
            }

            // FULL NIGHT: [dayLen + DUSK_POST, 24 - DAWN_PRE)
            const nightCore = nightLen - DUSK_POST - DAWN_PRE;
            const nightMid = dayLen + nightLen / 2;
            const tFromMid = Math.abs(hoursSince(0, t) - hoursSince(0, nightMid > 24 ? nightMid - 24 : nightMid));
            const nightHalf = nightCore / 2;
            const np = nightHalf > 0 ? Math.min(1, Math.min(tFromMid, 24 - tFromMid) / nightHalf) : 0;
            return lerpColor(NIGHT, TWILIGHT, np * 0.3);
        }

        // ===== SVG HELPERS =====
        function polar(cx, cy, r, deg) {
            const rad = (deg - 90) * Math.PI / 180;
            return [cx + r * Math.cos(rad), cy + r * Math.sin(rad)];
        }

        function wedge(cx, cy, r1, r2, a1, a2) {
            if (a2 < a1) a2 += 360;
            const [ox1, oy1] = polar(cx, cy, r2, a1);
            const [ox2, oy2] = polar(cx, cy, r2, a2);
            const [ix2, iy2] = polar(cx, cy, r1, a2);
            const [ix1, iy1] = polar(cx, cy, r1, a1);
            const lg = (a2 - a1) > 180 ? 1 : 0;
            return `M${ox1},${oy1} A${r2},${r2} 0 ${lg} 1 ${ox2},${oy2} L${ix2},${iy2} A${r1},${r1} 0 ${lg} 0 ${ix1},${iy1} Z`;
        }

        function wedgeFull(cx, cy, r, a1, a2) {
            if (a2 < a1) a2 += 360;
            const [x1, y1] = polar(cx, cy, r, a1);
            const [x2, y2] = polar(cx, cy, r, a2);
            const lg = (a2 - a1) > 180 ? 1 : 0;
            return `M${cx},${cy} L${x1},${y1} A${r},${r} 0 ${lg} 1 ${x2},${y2} Z`;
        }

        // ===== BUILD SOLAR CLOCK SVG =====
        function buildSolarClockSVG(now, sunrise, sunset, hours, currentHourIdx) {
            const W = 500, H = 500;
            const cx = W / 2, cy = H / 2;

            // Radii
            const R_OUTER = 245;
            const R_HOUR_OUT = 240;
            const R_HOUR_IN = 205;
            const R_SKY = 200;
            const R_PEAK = 80;
            const R_CENTER = 68;

            const sunriseH = sunrise ? toDecimalHours(sunrise) : 6;
            const sunsetH = sunset ? toDecimalHours(sunset) : 18;
            const nowH = toDecimalHours(now);
            const nowAngle = timeToAngle(nowH);
            const sunriseAngle = timeToAngle(sunriseH);
            const sunsetAngle = timeToAngle(sunsetH);

            let s = `<svg viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg">`;

            // Defs
            s += `<defs>`;
            s += `<filter id="sunGlow"><feGaussianBlur stdDeviation="4" result="blur"/><feComposite in="SourceGraphic" in2="blur" operator="over"/></filter>`;
            s += `<filter id="softGlow"><feGaussianBlur stdDeviation="1.5" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>`;
            s += `<filter id="textShadow"><feDropShadow dx="0" dy="0" stdDeviation="2" flood-color="#000" flood-opacity="0.6"/></filter>`;
            s += `<clipPath id="skyClip"><circle cx="${cx}" cy="${cy}" r="${R_SKY}"/></clipPath>`;
            s += `</defs>`;

            // ===== LAYER 1: SKY GRADIENT DISC =====
            const NUM_SLICES = 90;
            const SLICE_DEG = 360 / NUM_SLICES;
            s += `<g clip-path="url(#skyClip)">`;
            for (let i = 0; i < NUM_SLICES; i++) {
                const a1 = i * SLICE_DEG;
                const a2 = (i + 1) * SLICE_DEG + 0.5; // slight overlap to avoid gaps
                const midA = (a1 + a2) / 2;
                const col = skyColor(midA, sunriseH, sunsetH);
                s += `<path d="${wedgeFull(cx, cy, R_SKY + 2, a1, a2)}" fill="rgb(${col.r},${col.g},${col.b})"/>`;
            }
            s += `</g>`;

            // Subtle radial overlay for depth
            s += `<circle cx="${cx}" cy="${cy}" r="${R_SKY}" fill="none" stroke="#151530" stroke-width="1"/>`;

            // ===== LAYER 2: HORIZON LINE =====
            // Draw a subtle horizon line at sunrise/sunset level
            if (sunrise && sunset) {
                const [srx, sry] = polar(cx, cy, R_SKY - 5, sunriseAngle);
                const [ssx, ssy] = polar(cx, cy, R_SKY - 5, sunsetAngle);
                // Arc through the night side (bottom) connecting sunrise and sunset
                s += `<line x1="${srx}" y1="${sry}" x2="${ssx}" y2="${ssy}" stroke="rgba(200,180,140,0.15)" stroke-width="1" stroke-dasharray="4,4"/>`;
            }

            // ===== LAYER 3: SUN ARC + SUN DOT =====
            if (sunrise && sunset) {
                // Sun arc — sinusoidal path from sunrise to sunset
                const daySpan = ((sunsetAngle - sunriseAngle) + 360) % 360;
                const STEPS = 80;
                const arcPoints = [];

                for (let i = 0; i <= STEPS; i++) {
                    const t = i / STEPS;
                    const angle = (sunriseAngle + t * daySpan) % 360;
                    const elev = Math.sin(t * Math.PI);
                    const r = R_SKY - 10 - elev * (R_SKY - 10 - R_PEAK);
                    const [px, py] = polar(cx, cy, r, angle);
                    arcPoints.push(`${px.toFixed(1)},${py.toFixed(1)}`);
                }

                s += `<polyline points="${arcPoints.join(' ')}" fill="none" stroke="rgba(240,192,64,0.25)" stroke-width="1.5" stroke-dasharray="5,4" stroke-linecap="round"/>`;

                // Small dots along the arc at hourly intervals
                const dayLenH = ((sunsetH - sunriseH) % 24 + 24) % 24;
                for (let dh = 1; dh < Math.floor(dayLenH); dh++) {
                    const t = dh / dayLenH;
                    const angle = (sunriseAngle + t * daySpan) % 360;
                    const elev = Math.sin(t * Math.PI);
                    const r = R_SKY - 10 - elev * (R_SKY - 10 - R_PEAK);
                    const [dx, dy] = polar(cx, cy, r, angle);
                    s += `<circle cx="${dx}" cy="${dy}" r="1.5" fill="rgba(240,192,64,0.35)"/>`;
                }

                // Current sun position (handle midnight wrap)
                const hSinceRise = hoursSince(sunriseH, nowH);
                const isDaytime = hSinceRise <= dayLenH;
                if (isDaytime) {
                    const tNow = hSinceRise / dayLenH;
                    const elevNow = Math.sin(tNow * Math.PI);
                    const rNow = R_SKY - 10 - elevNow * (R_SKY - 10 - R_PEAK);
                    const [sx, sy] = polar(cx, cy, rNow, nowAngle);
                    // Sun glow
                    s += `<circle cx="${sx}" cy="${sy}" r="14" fill="rgba(240,192,64,0.15)"/>`;
                    s += `<circle cx="${sx}" cy="${sy}" r="8" fill="#f0c040" filter="url(#sunGlow)" opacity="0.9"/>`;
                    s += `<circle cx="${sx}" cy="${sy}" r="4" fill="#fff" opacity="0.95"/>`;
                } else {
                    // Moon indicator at current angle (night)
                    const nowJd = julianDay(now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(),
                        now.getUTCHours() + now.getUTCMinutes() / 60);
                    const moon = getMoonPhase(nowJd);
                    const rMoon = R_SKY - 30;
                    const [mx, my] = polar(cx, cy, rMoon, nowAngle);
                    s += `<circle cx="${mx}" cy="${my}" r="6" fill="rgba(192,200,216,0.15)"/>`;
                    s += `<circle cx="${mx}" cy="${my}" r="4" fill="#c0c8d8" opacity="0.7"/>`;
                    s += `<circle cx="${mx}" cy="${my}" r="2" fill="#e0e4f0" opacity="0.9"/>`;
                }
            }

            // ===== LAYER 4: PLANETARY HOUR RING =====
            if (hours) {
                const nowMs = now.getTime();
                for (let i = 0; i < 24; i++) {
                    const h = hours[i];
                    let a1 = timeToAngle(toDecimalHours(h.start));
                    let a2 = timeToAngle(toDecimalHours(h.end));

                    // Handle midnight crossing: if end is after start in time but angle wrapped
                    if (h.end.getTime() > h.start.getTime() && a2 < a1) {
                        a2 += 360;
                    }

                    const GAP = 0.4;
                    const pa1 = a1 + GAP;
                    const pa2 = a2 - GAP;

                    if (pa2 <= pa1) continue;

                    const isCurrent = i === currentHourIdx;
                    const isPast = nowMs >= h.end.getTime();

                    const opacity = isCurrent ? 0.55 : (isPast ? 0.08 : 0.22);
                    const strokeW = isCurrent ? 1.5 : 0.3;
                    const strokeC = isCurrent ? h.planet.hex : '#1e1e3a';

                    s += `<path d="${wedge(cx, cy, R_HOUR_IN, R_HOUR_OUT, pa1, pa2)}" fill="${h.planet.hex}" fill-opacity="${opacity}" stroke="${strokeC}" stroke-width="${strokeW}"${isCurrent ? ' filter="url(#softGlow)"' : ''}/>`;

                    // Planet symbol
                    const midA = (pa1 + pa2) / 2;
                    const segSpan = pa2 - pa1;
                    if (segSpan > 4) {
                        const [px, py] = polar(cx, cy, (R_HOUR_IN + R_HOUR_OUT) / 2, midA);
                        const pSize = isCurrent ? 13 : (segSpan > 10 ? 10 : 7);
                        const pColor = isCurrent ? '#fff' : (isPast ? '#2a2a3a' : h.planet.hex);
                        s += `<text x="${px}" y="${py}" fill="${pColor}" font-size="${pSize}" text-anchor="middle" dominant-baseline="central" font-weight="${isCurrent ? 'bold' : 'normal'}">${h.planet.symbol}</text>`;
                    }
                }

                // Current hour hand
                if (currentHourIdx >= 0) {
                    const h = hours[currentHourIdx];
                    const [hx, hy] = polar(cx, cy, R_HOUR_IN + 3, nowAngle);
                    const [hex, hey] = polar(cx, cy, R_HOUR_OUT - 3, nowAngle);
                    s += `<line x1="${hx}" y1="${hy}" x2="${hex}" y2="${hey}" stroke="#fff" stroke-width="2.5" stroke-linecap="round" opacity="0.8"/>`;
                    s += `<circle cx="${hex}" cy="${hey}" r="3" fill="#fff" opacity="0.9"/>`;
                }
            }

            // ===== LAYER 5: HOUR TICK MARKS =====
            const R_TICK_OUT = R_OUTER;
            const R_TICK_IN_MAJOR = R_HOUR_OUT + 2;
            const R_TICK_IN_MINOR = R_HOUR_OUT + 5;
            const R_LABEL = R_OUTER + 2;

            for (let h = 0; h < 24; h++) {
                const angle = timeToAngle(h);
                const isMajor = (h % 6 === 0);
                const isEven = (h % 2 === 0);

                if (isEven) {
                    const innerR = isMajor ? R_TICK_IN_MAJOR : R_TICK_IN_MINOR;
                    const [x1, y1] = polar(cx, cy, R_TICK_OUT, angle);
                    const [x2, y2] = polar(cx, cy, innerR, angle);
                    s += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${isMajor ? '#6a6490' : '#3a3a5a'}" stroke-width="${isMajor ? 1.5 : 0.8}"/>`;
                } else {
                    // Small tick for odd hours
                    const [x1, y1] = polar(cx, cy, R_TICK_OUT, angle);
                    const [x2, y2] = polar(cx, cy, R_TICK_OUT - 3, angle);
                    s += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#2a2a4a" stroke-width="0.5"/>`;
                }
            }

            // Even-hour labels
            for (let h = 0; h < 24; h += 2) {
                const angle = timeToAngle(h);
                const label = h === 0 ? '24' : String(h).padStart(2, '0');
                const [lx, ly] = polar(cx, cy, R_LABEL + 10, angle);
                const isMajor = h % 6 === 0;
                s += `<text x="${lx}" y="${ly}" fill="${isMajor ? '#7a7498' : '#4a4468'}" font-size="${isMajor ? 10 : 8}" text-anchor="middle" dominant-baseline="central" font-family="Raleway,sans-serif" font-weight="${isMajor ? '600' : '400'}">${label}</text>`;
            }

            // ===== LAYER 6: SUNRISE/SUNSET LABELS =====
            if (sunrise && sunset) {
                // Sunrise
                const srLabelAngle = sunriseAngle;
                const [srx, sry] = polar(cx, cy, R_SKY - 18, srLabelAngle);
                s += `<text x="${srx}" y="${sry}" fill="#f0c040" font-size="8.5" text-anchor="middle" dominant-baseline="central" font-family="Cinzel,serif" font-weight="600" filter="url(#textShadow)">\u2600 ${fmtTime(sunrise)}</text>`;

                // Sunset
                const ssLabelAngle = sunsetAngle;
                const [ssx, ssy] = polar(cx, cy, R_SKY - 18, ssLabelAngle);
                s += `<text x="${ssx}" y="${ssy}" fill="#6080b0" font-size="8.5" text-anchor="middle" dominant-baseline="central" font-family="Cinzel,serif" font-weight="600" filter="url(#textShadow)">\u263D ${fmtTime(sunset)}</text>`;
            }

            // ===== LAYER 7: CENTER DISPLAY =====
            // Dark backing circle
            s += `<circle cx="${cx}" cy="${cy}" r="${R_CENTER}" fill="#06060f" fill-opacity="0.85" stroke="#252545" stroke-width="0.5"/>`;

            // Progress arc (current planetary hour)
            if (hours && currentHourIdx >= 0) {
                const h = hours[currentHourIdx];
                const elapsed = Math.min(1, Math.max(0, (now.getTime() - h.start.getTime()) / (h.end.getTime() - h.start.getTime())));
                const arcR = R_CENTER - 3;
                const arcAngle = elapsed * 360;
                if (arcAngle > 1) {
                    const startA = -90;
                    const endA = startA + arcAngle;
                    const startRad = startA * Math.PI / 180;
                    const endRad = endA * Math.PI / 180;
                    const ax1 = cx + arcR * Math.cos(startRad);
                    const ay1 = cy + arcR * Math.sin(startRad);
                    const ax2 = cx + arcR * Math.cos(endRad);
                    const ay2 = cy + arcR * Math.sin(endRad);
                    const largeArc = arcAngle > 180 ? 1 : 0;
                    s += `<path d="M${ax1},${ay1} A${arcR},${arcR} 0 ${largeArc} 1 ${ax2},${ay2}" fill="none" stroke="${h.planet.hex}" stroke-width="2" opacity="0.45" stroke-linecap="round"/>`;
                }
            }

            // Time
            const hh = String(now.getHours()).padStart(2, '0');
            const mm = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');

            s += `<text x="${cx}" y="${cy - 20}" fill="#e8e0f8" font-size="26" text-anchor="middle" dominant-baseline="central" font-family="Cinzel,serif" font-weight="700" letter-spacing="0.06em">${hh}:${mm}</text>`;
            s += `<text x="${cx}" y="${cy}" fill="#5a5478" font-size="12" text-anchor="middle" dominant-baseline="central" font-family="'Courier New',monospace">${ss}</text>`;

            // Amareth date
            const zd = gregorianToZodiac(todayUTC, userLat, userLng);
            s += `<text x="${cx}" y="${cy + 16}" fill="#c8a84e" font-size="10" text-anchor="middle" dominant-baseline="central" font-family="Cinzel,serif" font-weight="600">${zd.day} ${zd.sign.name}</text>`;

            // Sign + planet of the hour
            if (hours && currentHourIdx >= 0) {
                const h = hours[currentHourIdx];
                s += `<text x="${cx}" y="${cy + 30}" fill="#7a7498" font-size="9" text-anchor="middle" dominant-baseline="central">${zd.sign.symbol} \u00b7 ${h.planet.symbol} ${h.planet.name}</text>`;
            } else {
                s += `<text x="${cx}" y="${cy + 30}" fill="#7a7498" font-size="9" text-anchor="middle" dominant-baseline="central">${zd.sign.symbol} \u00b7 ${fmtAmarethYear(zd.year)}</text>`;
            }

            s += `</svg>`;
            return s;
        }

        // ===== RENDER CLOCK =====
        function renderClock() {
            const now = new Date();
            const container = document.getElementById('solar-container');

            if (userLat === null) {
                container.innerHTML = buildSolarClockSVG(now, null, null, null, -1);
                return;
            }

            const st = getSunTimes(now, userLat, userLng);

            // Check polar conditions
            if (st.polarDay) {
                polarState = 'day';
                renderPolarWarning();
                container.innerHTML = buildSolarClockSVG(now, null, null, null, -1);
                return;
            }
            if (st.polarNight) {
                polarState = 'night';
                renderPolarWarning();
                container.innerHTML = buildSolarClockSVG(now, null, null, null, -1);
                return;
            }

            polarState = null;
            renderPolarWarning();

            const nowMs = now.getTime();

            // Determine which sunrise/sunset cycle we're in
            let sunrise = st.sunrise, sunset = st.sunset, nextSunrise, dayOfWeek = now.getDay();

            if (nowMs < st.sunrise.getTime()) {
                // Before today's sunrise — use yesterday's cycle
                const yesterday = new Date(now.getTime() - DAY_MS);
                const stYest = getSunTimes(yesterday, userLat, userLng);
                if (stYest.polarDay || stYest.polarNight) {
                    container.innerHTML = buildSolarClockSVG(now, null, null, null, -1);
                    return;
                }
                sunrise = stYest.sunrise;
                sunset = stYest.sunset;
                nextSunrise = st.sunrise;
                dayOfWeek = yesterday.getDay();
            } else {
                const tomorrow = new Date(now.getTime() + DAY_MS);
                const stTom = getSunTimes(tomorrow, userLat, userLng);
                if (stTom.polarDay || stTom.polarNight) {
                    container.innerHTML = buildSolarClockSVG(now, sunrise, sunset, null, -1);
                    return;
                }
                nextSunrise = stTom.sunrise;
            }

            const ph = getPlanetaryHours(sunrise, sunset, nextSunrise, dayOfWeek);
            let ci = -1;
            for (let i = 0; i < ph.hours.length; i++) {
                if (nowMs >= ph.hours[i].start.getTime() && nowMs < ph.hours[i].end.getTime()) {
                    ci = i;
                    break;
                }
            }

            container.innerHTML = buildSolarClockSVG(now, sunrise, sunset, ph.hours, ci);
        }

        function renderPolarWarning() {
            const el = document.getElementById('polar-warning');
            if (!polarState) { el.style.display = 'none'; return; }
            el.style.display = 'block';
            const isPolarDay = polarState === 'day';
            el.innerHTML = `<div class="polar-warning">
                <div class="pw-icon">${isPolarDay ? '\u2600\uFE0F' : '\uD83C\uDF11'}</div>
                <div class="pw-title">${isPolarDay ? 'Dzien polarny' : 'Noc polarna'}</div>
                <div class="pw-detail">
                    ${isPolarDay ? 'Brak zachodu Slonca' : 'Brak wschodu Slonca'} w tej lokalizacji.<br>
                    Godziny planetarne sa niedostepne.
                </div>
            </div>`;
        }

        // ===== LOCATION HANDLING =====
        function updateThemeLinks() {
            const classicLink = document.getElementById('classic-link');
            if (classicLink && userLat !== null) classicLink.href = `index.html?lat=${userLat}&lng=${userLng}`;
            const astroLink = document.getElementById('astro-link');
            if (astroLink && userLat !== null) astroLink.href = `astro.html?lat=${userLat}&lng=${userLng}`;
        }

        function setLocation(lat, lng, label) {
            userLat = lat;
            userLng = lng;
            document.getElementById('loc-status').textContent = `${label} (${lat.toFixed(2)}, ${lng.toFixed(2)})`;
            document.getElementById('lat-input').value = lat.toFixed(2);
            document.getElementById('lng-input').value = lng.toFixed(2);
            updateThemeLinks();
            renderClock();
        }

        window.requestGeolocation = function() {
            if (!navigator.geolocation) {
                document.getElementById('loc-status').textContent = 'Geolokalizacja niedostepna w tej przegladarce';
                return;
            }
            document.getElementById('loc-status').textContent = 'Pobieram lokalizacje...';
            navigator.geolocation.getCurrentPosition(
                (pos) => setLocation(pos.coords.latitude, pos.coords.longitude, 'Twoja lokalizacja'),
                (err) => { document.getElementById('loc-status').textContent = 'Nie udalo sie pobrac lokalizacji: ' + err.message; }
            );
        };

        window.selectCity = function(val) {
            if (!val) return;
            const [lat, lng] = val.split(',').map(Number);
            const sel = document.getElementById('city-select');
            const label = sel.options[sel.selectedIndex].text;
            setLocation(lat, lng, label);
        };

        window.setManualLocation = function() {
            const lat = parseFloat(document.getElementById('lat-input').value);
            const lng = parseFloat(document.getElementById('lng-input').value);
            if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                document.getElementById('loc-status').textContent = 'Nieprawidlowe wspolrzedne';
                return;
            }
            setLocation(lat, lng, 'Reczna lokalizacja');
        };

        window.toggleConfig = function() {
            const bar = document.getElementById('location-bar');
            bar.style.display = bar.style.display === 'none' ? 'block' : 'none';
        };

        // ===== INIT =====
        document.getElementById('loc-status').textContent = `Torun (${userLat.toFixed(2)}, ${userLng.toFixed(2)})`;
        document.getElementById('lat-input').value = userLat.toFixed(2);
        document.getElementById('lng-input').value = userLng.toFixed(2);
        document.getElementById('city-select').value = '53.01,18.60';
        updateThemeLinks();

        renderClock();
        setInterval(renderClock, 1000);
    </script>
</body>
</html>
